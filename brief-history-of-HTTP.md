# HTTP 简史
超文本传输​​协议（HTTP）是互联网上最普遍并广泛采用的应用协议之一：它是客户端和服务器之间通信的常见语言，用于实现现代 Web。从简单的一个单一的关键字和文档路径开始，它已经不仅适用于浏览器，几乎应用在每个由互联网连接起来的软件和硬件。

本章将简要介绍 HTTP 协议的演进过程。全面讨论所有 HTTP 的语义超出了本书的范围，但是了解 HTTP 的关键设计变更以及背后的动机将为我们讨论 HTTP 的性能提供必要的背景知识，特别是在即将到来的 HTT /2 中带来的改进。

## 一行的 HTTP 0.9 协议
Tim Berners-Lee 设计的原始 HTTP 提案很简单用于帮助采用他的另一个新想法：万维网。这个策略似乎有效：注意他是一个有抱负的协议设计者。

1991 年，Berners-Lee 简述了新协议的动机，列出了几个高级设计目标：文件传输功能，能够请求对超文本存档的索引搜索，格式协商以及能够让客户端跳转到另一个服务器。为了用行动证明理论，他建立了一个实现了所提议功能一小部分的简单原型。

1. 客户端的请求是单个 ASCII 字符串。
2. 客户端请求由回车（CRLF）终止。
4. 服务器响应是 ASCII 字符流。
5. 服务器响应是超文本标记语言（HTML）。
6. 连接在文档传输完成后终止。

然而，即使这样描述也比真实协议更复杂。实现这些规则极度简单并且对  Telnet 协议友好。
> $> telnet google.com 80
> Connected to 74.125.xxx.xxx
> 
> GET /about/
> 
> (hypertext response)
> (connection closed)

该请求只有一行：**GET** 方法和请求文档的路径。响应是单个超文本文档 - 不包含标题或任何其他元数据，只是 HTML。它真的不能更简单。此外，由于先前的交互是预期协议的子集，所以它非正式地获取了 HTTP0.9 标签。正如他们所说，其余的都是历史。

从 1991 年这些简陋的规则开始，HTTP 在未来几年内展现了它的生机并迅速发展。让我们快速回顾一下 HTTP0.9 的特点：

1. 客户端-服务器，请求-响应协议。
2. ASCII 协议，运行在 TCP/IP 链路上。
3. 设计用来传输超文本文件（HTML）。
4. 每个请求后关闭服务器和客户端之间的连接。

**note**
流行的 Web 服务器，如 Apache 和 Nginx，仍然支持 HTTP0.9 协议，部分是因为它很简单！如果您好奇的话，打开一个 Telnet 对话并尝试通过 HTTP0.9 访问google.com 或您自己喜欢的站点，并检查此早期协议的行为和限制。

# HTTP/1.0：快速增长和信息 RFC
在 1991 年到 1995 年之间，HTML规范以及被称为“网络浏览器”的新型软件共同快速发展。以消费者为导向的公共互联网基础设施迅速增长。

>**完美风暴：20 世纪 90 年代初互联网的爆发**
>基于 Tim Berner-Lee 最初的浏览器原型，国家超级计算应用中心（NCSA）的一个团队决定实现自己的版本。第一个主流浏览器就这样诞生了：NCSA Mosaic。NCSA 团队中的一名程序员 Marc Andreessen 与 Jim Clark 合作，于 1994 年 10 月成立 Mosaic Communications 公司，后来更名为 Netscape，并于1994 年 12 月发布了 Netscape Navigator 1.0。至此，万维网已经不仅仅只有学术意义。
>
>事实上，第一次世界范围的万维网会议在瑞士日内瓦在同年举行，这导致了旨在帮助指导 HTML 发展的万维网联盟(W3C)的创立。类似地，IETF 中同时建立了一个致力于改进 HTTP 协议的 HTTP 工作组(HTTP-WG)。这两个小组对网络的演进起到了重要的作用。
>
>最后，为了创造一个完美风暴，CompuServe, AOL 和 Prodigy 开始在 1994-1995 年期间提供拨号上网服务。在这波迅速接受的浪潮中，网景公司在 1995 年 8 月 9 日成功的上市创造了历史，标志着互联网的繁荣到来了，每个人都想要分一份羹!

新兴 Web 的期望功能列表及其在公共 Web 上的使用方式迅速暴露了 HTTP 0.9 的许多基本限制：我们需要一个不仅可以服务于超文本文档，还可以提供更多关于请求的元数据响应，启用内容协商等等的协议。反过来，网络开发人员的新兴社区通过生成大量实验性的 HTTP 服务器和客户端作为响应：实施，部署并查看其他人是否采纳。

从快速实验期开始，出现了一套最佳实践和常见模式，1996 年 5 月，HTTP 工作组（HTTP-WG）发布了 RFC 1945，该文件记录了许多 HTTP/1.0 的“常见用法”。请注意，这只是一个信息 RFC：正如我们知道的 HTTP/1.0 不是正式的规范或 Internet 标准！

话虽如此，HTTP/1.0 的示例看起来应该很熟悉：
```
$> telnet website.org 80

Connected to xxx.xxx.xxx.xxx

GET /rfc/rfc1945.txt HTTP/1.0 注1
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
Accept: */*

HTTP/1.0 200 OK 注2
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 01 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 1 May 1996 12:45:26 GMT
Server: Apache 0.84

(plain-text response)
(connection closed)
```

注1：请求行与 HTTP 版本号，后跟请求头

注2：响应状态，后跟响应头

上述交换不是 HTTP/1.0 详尽的功能列表，但它说明了一些关键的协议改变：

1. 请求可能包含多个按行分割的头字段。
2. 响应对象以响应状态行为前缀。
3. 响应对象有自己的按行分割的头字段。
4. 响应对象不限于超文本。
5. 每个请求后，服务器和客户端之间的连接关闭。

请求和响应头都用 ASCII 编码保存，但响应对象本身可以是任何类型：HTML 文件，纯文本文件，图像或任何其他内容类型。因此，HTTP 的“超文本传输​​”在引入后不久就部分成为了一个误解。在现实中，HTTP 已经迅速发展成为了一个超媒体传输，但是原来的名字就被卡住了。

除了媒体类型协商外，RFC 还记录了许多其他常用功能：内容编码，字符集支持，多部分类型，授权，缓存，代理行为，日期格式等。

**note**
>网络上几乎每个服务器今天都可以并仍然会使用 HTTP/1.0。除此之外，你应该知道的更多！每个请求都建立新的 TCP 连接对 HTTP/1.0 会造成重大的性能损失;请参阅[三次握手](https://hpbn.co/building-blocks-of-tcp/#three-way-handshake)与[缓慢启动](https://hpbn.co/building-blocks-of-tcp/#slow-start)。
